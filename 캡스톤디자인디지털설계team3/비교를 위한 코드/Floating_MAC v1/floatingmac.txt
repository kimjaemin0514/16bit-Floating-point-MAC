module TOP(A,B,C,Y,OFout,CLK,RESETn);


input [15:0] A,B,C;
input CLK, RESETn;
output OFout;
output [15:0] Y;

floatingmac toop(.A(A),.B(B),.C(C),.Y(Y),.OFout(OFout),.CLK(CLK),.RESETn(RESETn));

endmodule

module floatingmac(A,B,C,Y,OFout,CLK,RESETn);

input [15:0] A,B,C;
input CLK, RESETn;
output OFout;
output [15:0] Y;

wire OFout1;
wire [15:0] AB;

reg [15:0] C0,C1,C2,C3,C4;
reg [15:0] AB1;
reg OFout2;

always @ (posedge CLK, negedge RESETn)
begin
	if (!RESETn)
		begin
			OFout2   <=0;
			AB1 	   <=0;
		end
	else
		begin
			C0 		<=C;
			C1			<=C0;
			C2			<=C1;
			C3			<=C2;
		
			AB1 		<= AB;
			OFout2	<= OFout1;
		end
end

//stage 1,2,3
	floatingmul mac1 (
		.A(A), 
		.B(B), 
		.Y(AB),
		.OF(OFout1),
		.CLK(CLK),
		.RESETn(RESETn)
	);

//stage4
	floatingadd mac2 (
		.A(AB1), 
		.B(C3), 
		.OFin(OFout2),
		.C(Y), 
		.OFout(OFout)
	);


endmodule

module floatingmul(A,B,Y,OF,CLK,RESETn);

input [15:0] A,B;
input CLK,RESETn;
output [15:0] Y;
output OF;

reg A_sign, B_sign, AB_sign,AB_sign0,AB_sign1,AB_sign2, AB_overflow;     //AB_overflow : exponent의 overflow
reg [4:0] A_exponent, B_exponent, AB_exponent;
reg [5:0] AB_ex, AB_ex0, AB_ex1, AB_ex2, AB_ex_1; 		//A_ex + B_ex : 실제 계산값 and +1
reg [9:0] A_fraction, B_fraction, AB_fraction;
reg [19:0] AB_fraction1;
reg [10:0] AB_fraction2;
reg [21:0] AB_frac1;
wire [23:0] AB_frac;	   // A_frac * B_frac : 실제 계산 값

wire [11:0] A_fraction1, B_fraction1;
always @ (posedge CLK)
begin
AB_sign0			<= AB_sign;
AB_ex0 	<= AB_ex;

AB_sign1			<= AB_sign0;
AB_ex1 	<= AB_ex0;

AB_sign2			<= AB_sign1;
AB_ex2 	<= AB_ex1;

end
always @ (*)
begin
	A_sign = A[15];
	A_exponent = A[14:10];
	A_fraction = A[9:0];

	B_sign = B[15];
	B_exponent = B[14:10];
	B_fraction = B[9:0];

//A*B 시작

//sign 부분
	AB_sign = A_sign ^ B_sign;

//exponent부분
	AB_ex = A_exponent + B_exponent - 15;
	if (AB_frac >= 22'b10_0000_0000_0000_0000_0000)
		AB_ex_1 = AB_ex2 + 1;
	else
		AB_ex_1 = AB_ex2;
   //overflow check	
	if (AB_ex_1 >= 6'b1_00000)
		AB_overflow=1;
	else if (AB_ex_1 < 6'b1_00000) //AB_ex_1이 존재하지 않는경우 0이될수도있음
		AB_overflow=0;

	AB_exponent = AB_ex_1[4:0];


//fraction 부분
	AB_frac1=AB_frac[21:0];
	
	if (AB_frac1 >= 22'b10_0000_0000_0000_0000_0000)
		AB_fraction1 = (AB_frac1 >>1);
	else
		AB_fraction1 = AB_frac1;
	
//rounding (guard bit, round bit, stickybit) nearest even.
	if (AB_fraction1[9]==0)
		AB_fraction2 = AB_fraction1[19:10];
	else	
		if (AB_fraction1[8:0] != 0)
			AB_fraction2 = AB_fraction1[19:10]+10'b1;
		else
			if (AB_fraction1[10]==1)
				AB_fraction2 = AB_fraction1[19:10]+10'b1;
			else
				AB_fraction2 = AB_fraction1[19:10];
	
	if (AB_fraction>=11'b1_00000_00000)
		AB_fraction = (AB_fraction2 >>1);
	else	
		AB_fraction = AB_fraction2;


end
//최종
assign A_fraction1={1'b0,1'b1,A_fraction};
assign B_fraction1={1'b0,1'b1,B_fraction};
booth_multiplier booth( A_fraction1, B_fraction1,AB_frac,CLK,RESETn);

assign OF= AB_overflow; 
assign Y={AB_sign2,AB_exponent,AB_fraction};

endmodule

module eight_bit_adder_subractor(cin,i0,i1,sum);

   input  cin;
   input  [11:0] i0,i1;
   output [11:0] sum;
	wire cout;
	wire [11:0] int_ip; //intermediate input - processed from the inputs and fed into fa module 
	
	//if cin == 1, int_ip = 1's complement
	//else int_ip = i1
    xor2 x0 (i1[0], cin, int_ip[0]);
    xor2 x1 (i1[1], cin, int_ip[1]);
    xor2 x2 (i1[2], cin, int_ip[2]);
    xor2 x3 (i1[3], cin, int_ip[3]);
    xor2 x4 (i1[4], cin, int_ip[4]);
    xor2 x5 (i1[5], cin, int_ip[5]);
    xor2 x6 (i1[6], cin, int_ip[6]);
    xor2 x7 (i1[7], cin, int_ip[7]);
    xor2 x8 (i1[8], cin, int_ip[8]);
    xor2 x9 (i1[9], cin, int_ip[9]);
	 xor2 x10 (i1[10], cin, int_ip[10]);
	 xor2 x11 (i1[11], cin, int_ip[11]);
	 
	//if cin == 1, int_ip = 2's complement	 
    CLA_12bit CLA (i0,int_ip,cin,sum,cout);    


////////////////////////////////////////////carrylookahead 필요//////////////////////////////////////////////////////////////////
endmodule


module booth_substep(
    input wire signed [11:0] acc,    //Current value of accumulator
    input wire signed [11:0] Q,  //Current value of Q (initially the multiplier)    
    input wire signed q0,       //Current value of q-1 th bit
    input wire signed [11:0] multiplicand,  //the multipliand
    output reg signed [11:0] next_acc,   //next accumulator value || value of 8 MSB's of 16 bit output [17:8]
    output reg signed [11:0] next_Q, //Next value of Q || value of 8 LSB's of 16 bit output [7:0]
    output reg q0_next);
    
	wire [11:0] addsub_temp;  //next value of q_-1 th bit
	
	eight_bit_adder_subractor myadd(Q[0], acc, multiplicand, addsub_temp);
	
		always @(*) begin	
		if(Q[0] == q0) begin
            q0_next = Q[0];
            next_Q = Q>>1;
            next_Q[11] = acc[0];
            //right shift
            next_acc = acc>>1;
            //with sign extension
			if (acc[11] == 1)
					next_acc[11] = 1;
		end

		else begin        //if Q[0] != q0 (that is,  q_-1 bit)
            q0_next = Q[0];
            next_Q = Q>>1;
            next_Q[11] = addsub_temp[0];
            //right shift
            next_acc = addsub_temp>>1;
            //with sign extension
			if (addsub_temp[11] == 1)
                next_acc[11] = 1; 
		end			
end	
endmodule 

module booth_multiplier(multiplier, multiplicand,product,CLK,RESETn);
	input signed[11:0] multiplier, multiplicand;
	input CLK, RESETn;
	
	output signed [23:0] product;
	
	wire signed [11:0] Q[0:10];  //an 8 bit (1byte) array, with a depth of 7 (0 to 6 rows of 1 byte each)
	wire signed [11:0] acc[0:11]; //an 8 bit (1byte) array, with a depth of 8 (0 to 7 rows of 1 byte each)
	wire signed [11:0] q0;
	wire qout;
	
	reg signed [11:0] multiplicand0, multiplicand1, multiplicand2;
	reg signed [11:0] Q1[0:10], Q2[0:10];
	reg signed [11:0] acc1[0:11], acc2[0:11];
	reg signed [11:0] q01, q02;
	
	wire signed [11:0] q011;
	wire signed [11:0] acc11[0:11];
	wire signed [11:0] Q11[0:10];
	
	wire signed [11:0] q022;
	wire signed [11:0] acc22[0:11];
	wire signed [11:0] Q22[0:10];
	
	always @ (posedge CLK, negedge RESETn)
	begin
		if (!RESETn)
		begin
		
			acc1[0] 			<= 0;
			acc1[1]			<= 0;
			acc1[2]			<= 0;
			acc1[3]			<= 0;
			acc1[4]			<= 0;
			acc1[5]			<= 0;
			acc1[6]			<= 0;
			acc1[7]			<= 0;
			acc1[8]			<= 0;
			acc1[9]			<= 0;
			acc1[10]			<= 0;		
			acc1[11]			<= 0;				
			
			acc2[0] 			<= 0;
			acc2[1]			<= 0;
			acc2[2]			<= 0;
			acc2[3]			<= 0;
			acc2[4]			<= 0;
			acc2[5]			<= 0;
			acc2[6]			<= 0;
			acc2[7]			<= 0;
			acc2[8]			<= 0;
			acc2[9]			<= 0;
			acc2[10]			<= 0;		
			acc2[11]			<= 0;	
			
			Q1[0] 			<= 0;
			Q1[1]				<= 0;
			Q1[2]				<= 0;
			Q1[3]				<= 0;
			Q1[4]				<= 0;
			Q1[5]				<= 0;
			Q1[6]				<= 0;
			Q1[7]				<= 0;
			Q1[8]				<= 0;
			Q1[9]				<= 0;
			Q1[10]			<= 0;
			
			Q2[0] 			<= 0;
			Q2[1]				<= 0;
			Q2[2]				<= 0;
			Q2[3]				<= 0;
			Q2[4]				<= 0;
			Q2[5]				<= 0;
			Q2[6]				<= 0;
			Q2[7]				<= 0;
			Q2[8]				<= 0;
			Q2[9]				<= 0;
			Q2[10]			<= 0;			
						
			q01 				<= 0;
			multiplicand1	<=	0;
			q02				<= 0;
			multiplicand2	<=	0;
		end	
		else
		begin
		multiplicand0	<=	multiplicand;
			//stage1->2
			acc1[0] 			<=acc[0];
			acc1[1]			<=acc[1];
			acc1[2]			<=acc[2];
			acc1[3]			<=acc[3];
			acc1[4]			<=acc[4];
			acc1[5]			<=acc[5];
			acc1[6]			<=acc[6];
			acc1[7]			<=acc[7];
			acc1[8]			<=acc[8];
			acc1[9]			<=acc[9];
			acc1[10]			<=acc[10];		
			acc1[11]			<=acc[11];	
		
			Q1[0] 			<= Q[0];
			Q1[1]				<= Q[1];
			Q1[2]				<= Q[2];
			Q1[3]				<= Q[3];
			Q1[4]				<= Q[4];
			Q1[5]				<= Q[5];
			Q1[6]				<= Q[6];
			Q1[7]				<= Q[7];
			Q1[8]				<= Q[8];
			Q1[9]				<= Q[9];
			Q1[10]			<= Q[10];
			
			q01				<= q0;					
			multiplicand1	<=	multiplicand0;
			//stage2->3
			acc2[0] 			<=acc11[0];
			acc2[1]			<=acc11[1];
			acc2[2]			<=acc11[2];
			acc2[3]			<=acc11[3];
			acc2[4]			<=acc11[4];
			acc2[5]			<=acc11[5];
			acc2[6]			<=acc11[6];
			acc2[7]			<=acc11[7];
			acc2[8]			<=acc11[8];
			acc2[9]			<=acc11[9];
			acc2[10]			<=acc11[10];		
			acc2[11]			<=acc11[10];	
			
			Q2[0] 			<= Q11[0];
			Q2[1]				<= Q11[1];
			Q2[2]				<= Q11[2];
			Q2[3]				<= Q11[3];
			Q2[4]				<= Q11[4];
			Q2[5]				<= Q11[5];
			Q2[6]				<= Q11[6];
			Q2[7]				<= Q11[7];
			Q2[8]				<= Q11[8];
			Q2[9]				<= Q11[9];
			Q2[10]			<= Q11[10];
			
			q02				<= q011;
			multiplicand2	<=	multiplicand1;	
		end	
	end
	assign acc[0] = 12'b00000000;   //initialising accumulator to 0
	
assign acc11[0] 			=acc1[0];
assign acc11[1]			=acc1[1];
assign acc11[2]			=acc1[2];
assign acc11[3]			=acc1[3];
assign acc11[4]			=acc1[4];
assign acc11[5]			=acc1[5];			
assign acc11[6]			=acc1[6];
assign acc11[7]			=acc1[7];
assign acc11[8]			=acc1[8];
assign acc11[9]			=acc1[9];
assign acc11[10]			=acc1[10];		
assign acc11[11]			=acc1[11];	

assign	Q11[0] 	= Q1[0];
assign	Q11[1]	= Q1[1];
assign	Q11[2]	= Q1[2];
assign	Q11[3]	= Q1[3];
assign	Q11[4]	= Q1[4];
assign	Q11[5]	= Q1[5];
assign	Q11[6]	= Q1[6];
assign	Q11[7]	= Q1[7];
assign	Q11[8]	= Q1[8];
assign	Q11[9]	= Q1[9];
assign	Q11[10]	= Q1[10];

assign q011 = q01;

assign acc22[0] 			=acc2[0];
assign acc22[1]			=acc2[1];
assign acc22[2]			=acc2[2];
assign acc22[3]			=acc2[3];
assign acc22[4]			=acc2[4];
assign acc22[5]			=acc2[5];			
assign acc22[6]			=acc2[6];
assign acc22[7]			=acc2[7];
assign acc22[8]			=acc2[8];
assign acc22[9]			=acc2[9];
assign acc22[10]			=acc2[10];		
assign acc22[11]			=acc2[11];	

assign	Q22[0] 	= Q2[0];
assign	Q22[1]	= Q2[1];
assign	Q22[2]	= Q2[2];
assign	Q22[3]	= Q2[3];
assign	Q22[4]	= Q2[4];
assign	Q22[5]	= Q2[5];
assign	Q22[6]	= Q2[6];
assign	Q22[7]	= Q2[7];
assign	Q22[8]	= Q2[8];
assign	Q22[9]	= Q2[9];
assign	Q22[10]	= Q2[10];

assign q022 = q02;
			
	//stage1
	booth_substep step1(acc[0], multiplier, 1'b0, multiplicand, acc[1],        Q[0],         q0[1]);
	booth_substep step2(acc[1], Q[0],      q0[1], multiplicand, acc[2],        Q[1],         q0[2]);
	booth_substep step3(acc[2], Q[1],      q0[2], multiplicand, acc[3],        Q[2],         q0[3]);
	booth_substep step4(acc[3], Q[2],      q0[3], multiplicand, acc[4],        Q[3],         q0[4]);
	//stage2
	booth_substep step5(acc11[4], Q11[3],      q011[4], multiplicand1, acc11[5],        Q11[4],         q011[5]);
	booth_substep step6(acc11[5], Q11[4],      q011[5], multiplicand1, acc11[6],        Q11[5],         q011[6]);
	booth_substep step7(acc11[6], Q11[5],      q011[6], multiplicand1, acc11[7],        Q11[6],         q011[7]);
	booth_substep step8(acc11[7], Q11[6],      q011[7], multiplicand1, acc11[8],        Q11[7],         q011[8]);
	//stage3
	booth_substep step9(acc22[8], Q22[7],      q022[8], multiplicand2, acc22[9],        Q22[8],         q022[9]);
	booth_substep step10(acc22[9], Q22[8],      q022[9], multiplicand2, acc22[10],        Q22[9],         q022[10]);
	booth_substep step11(acc22[10], Q22[9],      q022[10], multiplicand2, acc22[11],        Q22[10],         q022[11]);
	booth_substep step12(acc22[11], Q22[10],      q022[11], multiplicand2, product[23:12], product[11:0], qout);
	
	 
endmodule

//lib.v
//xor module
module xor2 (input wire i0, i1, output wire o);
  assign o = i0 ^ i1;
endmodule

module CLA_12bit(a,b,ci,sum,cout);

        input   [11:0]  a;
        input   [11:0]  b;
        input           ci;
        output  [11:0]  sum;
        output          cout;

        wire [2:0] GG;
        wire [2:0] PP;
        wire [2:1] C;

        CLALogic_3 CarryLogic_2 (GG[2:0], PP[2:0], ci, C[2:1], cout, GGG, PPP);
		  
        CLA4 u0 (a[3: 0] , b[3: 0],  ci  , sum[3: 0],  GG[0], PP[0]);
        CLA4 u1 (a[7: 4] , b[7: 4],  C[1], sum[7: 4],  GG[1], PP[1]);
        CLA4 u2 (a[11:8] , b[11:8], C[2], sum[11:8],  GG[2], PP[2]);


endmodule
module CLA4(A,B,Ci,S,GG,PP);
        input [3:0] A;
        input [3:0] B;
        input Ci;

        output [3:0] S;
        output PP;
        output GG;

        wire [3:0] G;
        wire [3:0] P;
        wire [3:1] C;

        CLALogic_4 CarryLogic (G, P, Ci, C, Co, GG, PP);

        GPFullAdder FA0 (A[0], B[0], Ci, G[0], P[0], S[0]);
        GPFullAdder FA1 (A[1], B[1], C[1], G[1], P[1], S[1]);
        GPFullAdder FA2 (A[2], B[2], C[2], G[2], P[2], S[2]);
        GPFullAdder FA3 (A[3], B[3], C[3], G[3], P[3], S[3]);

endmodule
module GPFullAdder(X,Y,Cin,G,P,Sum);
        input X;
        input Y;
        input Cin;
        output G;
        output P;
        output Sum;

        assign G=X&Y;
        assign P=X^Y;
        assign Sum=P^Cin;
endmodule

module CLALogic_4 (G, P, Ci, C, Co, GG, PP);
        input [3:0] G;
        input [3:0] P;
        input Ci;
        output [3:1] C;
        output Co;
        output PP;
        output GG;

        assign PP=P[3] & P[2] & P[1] & P[0];
        assign GG=G[3] |
                (P[3] & G[2]) |
                (P[3] & P[2] & G[1]) |
                (P[3] & P[2] & P[1] & G[0]);
        assign Co = GG | (PP & Ci);

        assign C[1] = G[0] | (P[0] & Ci);
        assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Ci);
        assign C[3] = G[2] | (P[2] & G[1]) | (P[2] & P[1] & G[0]) | (P[2] & P[1] & P[0] & Ci);
endmodule		  
module CLALogic_3 (G, P, Ci, C, Co, GG, PP);
        input [2:0] G;
        input [2:0] P;
        input Ci;
        output [2:1] C;
        output Co;
        output PP;
        output GG;

        assign PP=P[2] & P[1] & P[0];
        assign GG=G[2] |
                (P[2] & G[1]) |
                (P[2] & P[1] & G[0]);
        assign Co = GG | (PP & Ci);

        assign C[1] = G[0] | (P[0] & Ci);
        assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Ci);

endmodule

module floatingadd(A,B,OFin,C,OFout);

input [15:0] A,B;
input OFin;
output reg[15:0] C;
output reg OFout;

reg A_sign, B_sign, C_sign;
reg [4:0] B_exponent, diff;
reg [5:0] A_exponent; // OFin으로 인해 overflow 발생할 수 도 있음.
reg [9:0] A_fraction, B_fraction;
reg [25:0] C_frac, C_frac2;
reg [9:0] C_fraction;
reg [5:0] C_exponent_1;
reg [4:0] C_exponent;

always @ (*)

begin
	A_sign = A[15];
	A_exponent[4:0] = A[14:10];
	A_exponent[5]= OFin;
	A_fraction = A[9:0];

	B_sign = B[15];
	B_exponent = B[14:10];
	B_fraction = B[9:0];
	
//A=B (exponent)
if (A_exponent == B_exponent) 
//A=B (fraction)
	if (A_fraction == B_fraction)
		if (A_sign==B_sign)
		begin
			C_sign = A_sign;
			C_exponent_1 = A_exponent+1;
				if (C_exponent_1 >= 6'b1_00000)
					OFout=1;
				else
					OFout=0;
			C_exponent = C_exponent_1 [4:0]; 
			C_fraction = A_fraction;
		end
		else
			C=0;
		
//A>B (fraction)
	if (A_fraction > B_fraction)
begin
	C_sign = A_sign;
	diff= A_exponent - B_exponent;
	if (A_sign^B_sign) //A,B 부호 다른경우
	C_frac = ({1'b1,A_fraction} << diff)- ({1'b1,B_fraction});
	else
	C_frac = ({1'b1,A_fraction} << diff)+ ({1'b1,B_fraction});// A+B 계산 EXPONENT 공통
	
	
	
	if (C_frac[diff+11] ==1 ) //overflow 발생경우
	begin
//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else
			C_frac2 = C_frac;

	if (diff>=2)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff-2]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else 
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;	
/////////////////////////////////////////////////////////////	
		C_fraction = C_frac2 >> (diff+1);
		C_exponent_1 = A_exponent + 1 ;
		if (C_exponent_1 >= 6'b1_00000)
			OFout=1;
		else
			OFout=0;
		C_exponent = C_exponent_1 [4:0];
	end
	
//	////
	else
	begin
//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else
			C_frac2 = C_frac;

	if (diff>=2)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff-2]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else 
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;		
/////////////////////////////////////////////////////////////	
		C_fraction = C_frac2 >> diff;
		C_exponent = A_exponent;
		OFout=0;
	end
end
/// A<B (fraction)
else
begin
	C_sign=B_sign;
	diff= B_exponent - A_exponent;
	if (A_sign^B_sign) //A,B 부호 다른경우
	C_frac = ({1'b1,B_fraction} << diff)-({1'b1,A_fraction});
	else
	C_frac = ({1'b1,B_fraction} << diff)+ ({1'b1,A_fraction});// A+B 계산 EXPONENT 공통
	
	if (C_frac[diff+11] == 1) //overflow 발생경우
	begin
//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else
			C_frac2 = C_frac;

	if (diff>=2)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff-2]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else 
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;	
/////////////////////////////////////////////////////////////	
		C_fraction = C_frac2 >> (diff+1);
		C_exponent_1 = B_exponent + 1 ;
		if (C_exponent_1 >= 6'b1_00000)
			OFout=1;
		else
			OFout=0;
		C_exponent = C_exponent_1 [4:0];
	end

	else
	begin
//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else
			C_frac2 = C_frac;

	if (diff>=2)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff-2]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else 
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;	
/////////////////////////////////////////////////////////////	
		C_fraction = C_frac2 >> diff;
		C_exponent = B_exponent;
		OFout=0;		
	end
end
//A>B인 경우	
if (A_exponent> B_exponent)
begin
	C_sign = A_sign;
	diff= A_exponent - B_exponent;
	if (A_sign^B_sign) //A,B 부호 다른경우
	C_frac = ({1'b1,A_fraction} << diff)- ({1'b1,B_fraction});
	else
	C_frac = ({1'b1,A_fraction} << diff)+ ({1'b1,B_fraction});// A+B 계산 EXPONENT 공통
	
	
	
	if (C_frac[diff+11] ==1 ) //overflow 발생경우
	begin
//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else
			C_frac2 = C_frac;

	if (diff>=2)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff-2]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else 
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;	
/////////////////////////////////////////////////////////////	
		C_fraction = C_frac2 >> (diff+1);
		C_exponent_1 = A_exponent + 1 ;
		if (C_exponent_1 >= 6'b1_00000)
			OFout=1;
		else
			OFout=0;
		C_exponent = C_exponent_1 [4:0];
	end
	
//	////
	else
	begin
//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else
			C_frac2 = C_frac;

	if (diff>=2)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff-2]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else 
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;		
/////////////////////////////////////////////////////////////	
		C_fraction = C_frac2 >> diff;
		C_exponent = A_exponent;
		OFout=0;
	end
end

//A<B인 경우
if (B_exponent > A_exponent)
begin
	C_sign=B_sign;
	diff= B_exponent - A_exponent;
	if (A_sign^B_sign) //A,B 부호 다른경우
	C_frac = ({1'b1,B_fraction} << diff)-({1'b1,A_fraction});
	else
	C_frac = ({1'b1,B_fraction} << diff)+ ({1'b1,A_fraction});// A+B 계산 EXPONENT 공통
	
	if (C_frac[diff+11] == 1) //overflow 발생경우
	begin
//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else
			C_frac2 = C_frac;

	if (diff>=2)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff-2]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else 
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;	
/////////////////////////////////////////////////////////////	
		C_fraction = C_frac2 >> (diff+1);
		C_exponent_1 = B_exponent + 1 ;
		if (C_exponent_1 >= 6'b1_00000)
			OFout=1;
		else
			OFout=0;
		C_exponent = C_exponent_1 [4:0];
	end

	else
	begin
//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else
			C_frac2 = C_frac;

	if (diff>=2)
	if (C_frac[diff-1]==0)
		C_frac2 = C_frac;
	else	
		if (C_frac[diff-2]==1)
			C_frac2 = C_frac+(1'b1 << (diff));
		else 
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;	
/////////////////////////////////////////////////////////////	
		C_fraction = C_frac2 >> diff;
		C_exponent = B_exponent;
		OFout=0;		
	end
end

 C={C_sign,C_exponent,C_fraction};

end


endmodule
