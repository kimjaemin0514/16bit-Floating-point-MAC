module TOP(A,B,C,Y,OutOfBound,CLK,RESETn);


input [15:0] A,B,C;
input CLK, RESETn;
output OutOfBound;
output [15:0] Y;

floatingmac toop(.A(A),.B(B),.C(C),.Y(Y),.OutOfBound(OutOfBound),.CLK(CLK),.RESETn(RESETn));

endmodule

module floatingmac(A,B,C,Y,OutOfBound,CLK,RESETn);

input [15:0] A,B,C;
input CLK, RESETn;
output OutOfBound;
output [15:0] Y;

wire [15:0] AB;
wire OutOfBound_inmul;
reg [15:0] C0,C1,C2,C3;
reg [15:0] AB1;
reg OutOfBound_inmul1;

always @ (posedge CLK, negedge RESETn)
begin
	if (!RESETn)
		begin
			AB1 	   <=0;
		end
	else
		begin
			C0 		<=C;
			C1			<=C0;
			C2			<=C1;
			C3			<=C2;
			AB1 		<= AB;
			OutOfBound_inmul1 <=OutOfBound_inmul;
		end
end

//stage 1,2,3
	floatingmul mac1 (
		.A(A), 
		.B(B), 
		.AB(AB),
		.OutOfBound(OutOfBound_inmul),
		.CLK(CLK),
		.RESETn(RESETn)
	);

//stage4
	floatingadd mac2 (
		.A(AB1), 
		.B(C3), 
		.OutOfBound_in(OutOfBound_inmul1),
		.SUM(Y),
		.OutOfBound(OutOfBound)
	);

endmodule

module floatingmul(A,B,AB,OutOfBound,CLK,RESETn);

input [15:0] A,B;
input CLK,RESETn;
output [15:0] AB;
output OutOfBound;

wire A_sign,B_sign;
wire [4:0] A_exponent, B_exponent;
wire [10:0] A_fraction, B_fraction;
wire AB_sign;
wire [4:0] AB_exponent;
wire [9:0]AB_fraction;
wire cin;

reg AB_sign1, AB_sign2, AB_sign3;
reg [4:0] A_exponent1, A_exponent2, A_exponent3, B_exponent1, B_exponent2, B_exponent3;
assign A_sign = A[15];
assign A_exponent = A[14:10];
assign A_fraction = {1'b1,A[9:0]}; //1.frac

assign B_sign = B[15];
assign B_exponent = B[14:10];
assign B_fraction = {1'b1,B[9:0]}; //1.frac

always @ (posedge CLK, negedge RESETn) begin
	if (!RESETn) begin
		AB_sign2 <= 0;
		AB_sign3 <= 0;
		A_exponent1 <=0;
		A_exponent2 <=0;
		B_exponent1 <=0;
		B_exponent2 <=0;
	end
	else begin
		AB_sign1 <= AB_sign ;
		AB_sign2 <= AB_sign1; 
		AB_sign3 <= AB_sign2;
		A_exponent1 <= A_exponent;
		A_exponent2 <= A_exponent1;
		A_exponent3 <= A_exponent2;
		B_exponent1 <= B_exponent;
		B_exponent2 <= B_exponent1;
		B_exponent3 <= B_exponent2;	
	end
end
sign s1 (A_sign,B_sign,AB_sign);
fraction s2 (A_fraction, B_fraction, AB_fraction, cin, CLK, RESETn);
exponent s3 (A_exponent3, B_exponent3, cin ,AB_exponent, OutOfBound);

assign AB = {AB_sign3, AB_exponent, AB_fraction};

endmodule
/////////////sign module///////////////

module sign(
input A,B,
output AB_sign
);

assign AB_sign = A ^ B;

endmodule	

/////////////fraction module///////////////

module fraction(
input [10:0] A,B,
output [9:0] AB_fraction,
output carry,
input CLK, RESETn
);

wire [21:0] AB_frac, AB_fraction1;

multi_11bit_piplined array (A, B, CLK, RESETn, AB_frac);
//rounding nearset to even (guard bit, round bit, stickybit)
assign AB_fraction1 = (!AB_frac[9]) ? AB_frac : (!AB_frac[8:0]) ? (AB_frac[10]) ? AB_frac+10'b10_0000_0000 : AB_frac : AB_frac+10'b10_0000_0000; //24bit 덧셈기
    
//output
assign AB_fraction = (AB_fraction1[21]) ? AB_fraction1[20:11] : AB_fraction1[19:10];
assign carry = (AB_fraction1[21]) ? 1'b1 : 1'b0;

endmodule
/////////////exponent module////////////////////

module exponent(
input [4:0] A,B,
input cin,
output [4:0] AB_exponent,
output OutOfBound
);
wire [5:0] AB_exponent1;
//bias = 4'b1000 (4'd15)
assign AB_exponent1 = A + B + cin - 4'b1111;
assign AB_exponent = (AB_exponent1[5]) ? 5'b0 : AB_exponent1[4:0];
assign OutOfBound = (AB_exponent1[5]) ? 1'b1 : 1'b0 ;
endmodule

module multi_11bit_piplined (a, b, CLK, RESETn, prod);
	
	input [10:0] a, b;
	input CLK, RESETn;
	output [21:0] prod;
	

	wire [21:0] partials0;
	wire [21:0] partials1;
	wire [21:0] partials2;
	wire [21:0] partials3;
	wire [21:0] partials4;
	wire [21:0] partials5;
	wire [21:0] partials6;
	wire [21:0] partials7;
	wire [21:0] partials8;
	wire [21:0] partials9;
	wire [21:0] partials10;

	reg [21:0] partials00;
	reg [21:0] partials111; 
	reg [10:0] a1;
	reg [10:0] b1;
	reg [10:0] a2;
	reg [10:0] b2;
	reg [10:0] a3;
	reg [10:0] b3;

	
always @ (posedge CLK or negedge RESETn) begin
	if (!RESETn) begin
	partials00<=0 ;
	partials111<=0 ;
	end
	else begin
	//stage 0->1
	a1 <= a;
	b1 <= b;
	//stage 1->2
	partials00 <= partials3 ;
	a2 <= a1;
	b2 <= b1;
	//stage 2->3
	partials111 <= partials7 ;
	a3 <= a2;
	b3 <= b2;

	end
end
   //stage1
   assign partials0  =  a[0]  ? b : 0;
	assign partials1  = (a[1]  ? b << 1  : 0) + partials0;
	assign partials2  = (a[2]  ? b << 2  : 0) + partials1;
	assign partials3  = (a[3]  ? b << 3  : 0) + partials2;
	//stage2
	assign partials4  = (a2[4]  ? b2 << 4  : 0) + partials00;
	assign partials5  = (a2[5]  ? b2 << 5  : 0) + partials4;
	assign partials6  = (a2[6]  ? b2 << 6  : 0) + partials5;
	assign partials7  = (a2[7]  ? b2 << 7  : 0) + partials6;
	//stage3
	assign partials8  = (a3[8]  ? b3 << 8  : 0) + partials111;
	assign partials9  = (a3[9]  ? b3 << 9  : 0) + partials8;
	assign partials10 = (a3[10] ? b3 << 10 : 0) + partials9;

	assign prod = (partials10[21]) ? partials10 : {1'b0,partials10};
endmodule


module floatingadd(A,B,OutOfBound_in,SUM,OutOfBound);

input [15:0] A,B;
input OutOfBound_in;
output reg [15:0] SUM;
output reg OutOfBound;   //결과값이 0인것도 OutOfBound 취급함.

reg A_sign, B_sign, C_sign;
reg [4:0] A_exponent,B_exponent, diff;
reg [10:0] A_fraction, B_fraction;
reg [24:0] C_frac, C_frac2;  //13번 shift부터는 똑같음.
reg [9:0] C_fraction;
reg [5:0] C_exponent_1;
reg [4:0] C_exponent;

always @ (*) begin
	if (OutOfBound_in)
		OutOfBound=1;
	else begin
	A_sign = A[15];
	A_exponent[4:0] = A[14:10];
	A_fraction = {1'b1,A[9:0]};

	B_sign = B[15];
	B_exponent = B[14:10];
	B_fraction = {1'b1,B[9:0]};
	
//A=B (exponent) & A=B (fraction)
if (A_exponent == B_exponent && A_fraction == B_fraction) begin
	if (A_sign==B_sign) begin
		C_sign = A_sign;
		C_exponent_1 = A_exponent+1;
		C_exponent = C_exponent_1 [4:0]; 
		C_fraction = A_fraction;
		end
		if (C_exponent_1[5] == 1'b1) 
			OutOfBound=1;
		else
			OutOfBound=0;	
end
else begin
	OutOfBound=1;
end
		
//A>B (fraction)
	if ( (A_exponent > B_exponent) || (A_exponent == B_exponent && A_fraction > B_fraction)) begin 
	C_sign = A_sign;
	diff = A_exponent - B_exponent;
	
		if (diff>=5'b01101) begin
			C_fraction = A_fraction[9:0];
			C_exponent = A_exponent;
			OutOfBound=0;
		end
		else begin 
			if (A_sign^B_sign) //A,B 부호 다른경우
				C_frac = (A_fraction << diff) - B_fraction;
			else 
				C_frac = (A_fraction << diff) + B_fraction;// A+B 계산 EXPONENT 공통	   //13번 shift부터는 똑같음.
		

	

//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1) begin
		if (C_frac[diff-1]==0)
			C_frac2 = C_frac;
		else	
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;
	end
	
	if (diff>=2) begin
		if (C_frac[diff-1]==0)
			C_frac2 = C_frac;
		else	
			if (C_frac[diff-2]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else 
				if (C_frac[diff]==1)
					C_frac2 = C_frac+(1'b1 << (diff));
				else
					C_frac2 = C_frac;	
	end
/////////////////////////////////////////////////////////////	
		if (C_frac2[diff+11] ==1 ) begin //overflow 발생경우
			C_fraction = C_frac2 >> (diff+1);
			C_exponent_1 = A_exponent + 1 ;
			if (C_exponent_1 >= 6'b1_00000)
				OutOfBound=1;
			else
				OutOfBound=0;
			C_exponent = C_exponent_1[4:0];
		end
	else begin
		C_fraction = C_frac2 >> diff;
		C_exponent_1 = A_exponent;
		if (C_exponent_1 >= 6'b1_00000)
			OutOfBound=1;
		else
			OutOfBound=0;
		C_exponent = C_exponent_1 [4:0];
	end
	end
end

//A<B인 경우
	
//B>A (fraction)
	if ( (B_exponent > A_exponent) || (B_exponent == A_exponent && B_fraction > A_fraction)) begin 
	C_sign = B_sign;
	diff = B_exponent - A_exponent;
	
		if (diff>=5'b01101) begin
			C_fraction = B_fraction[9:0];
			C_exponent = B_exponent;
			OutOfBound=0;
		end
		else begin 
			if (B_sign^A_sign) //B,A 부호 다른경우
				C_frac = (B_fraction << diff) - A_fraction;
			else 
				C_frac = (B_fraction << diff) + A_fraction;// B+A 계산 EXPONENT 공통	   //13번 shift부터는 똑같음.
		

	

//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1) begin
		if (C_frac[diff-1]==0)
			C_frac2 = C_frac;
		else	
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;
	end
	
	if (diff>=2) begin
		if (C_frac[diff-1]==0)
			C_frac2 = C_frac;
		else	
			if (C_frac[diff-2]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else 
				if (C_frac[diff]==1)
					C_frac2 = C_frac+(1'b1 << (diff));
				else
					C_frac2 = C_frac;	
	end
/////////////////////////////////////////////////////////////	
		if (C_frac2[diff+11] ==1 ) begin //overflow 발생경우
			C_fraction = C_frac2 >> (diff+1);
			C_exponent_1 = B_exponent + 1 ;
			if (C_exponent_1 >= 6'b1_00000)
				OutOfBound=1;
			else
				OutOfBound=0;
			C_exponent = C_exponent_1[4:0];
		end
	else begin
		C_fraction = C_frac2 >> diff;
		C_exponent_1 = B_exponent;
		if (C_exponent_1 >= 6'b1_00000)
			OutOfBound=1;
		else
			OutOfBound=0;
		C_exponent = C_exponent_1 [4:0];
	end
	end
end
end
		SUM={C_sign,C_exponent,C_fraction};

end	
endmodule