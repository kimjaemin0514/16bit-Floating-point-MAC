module TOP(multiplier, multiplicand,product,CLK,RESETn);

input signed[11:0] multiplier, multiplicand;
input CLK, RESETn;

	output signed [23:0] product;
booth_multiplier TOP(.multiplier(multiplier), .multiplicand(multiplicand),.product(product),.CLK(CLK),.RESETn(RESETn));

endmodule


module eight_bit_adder_subractor(cin,i0,i1,sum);

   input  cin;
   input  [11:0] i0,i1;
   output [11:0] sum;
	wire cout;
	wire [11:0] int_ip; //intermediate input - processed from the inputs and fed into fa module 
	
	//if cin == 1, int_ip = 1's complement
	//else int_ip = i1
    xor2 x0 (i1[0], cin, int_ip[0]);
    xor2 x1 (i1[1], cin, int_ip[1]);
    xor2 x2 (i1[2], cin, int_ip[2]);
    xor2 x3 (i1[3], cin, int_ip[3]);
    xor2 x4 (i1[4], cin, int_ip[4]);
    xor2 x5 (i1[5], cin, int_ip[5]);
    xor2 x6 (i1[6], cin, int_ip[6]);
    xor2 x7 (i1[7], cin, int_ip[7]);
    xor2 x8 (i1[8], cin, int_ip[8]);
    xor2 x9 (i1[9], cin, int_ip[9]);
	 xor2 x10 (i1[10], cin, int_ip[10]);
	 xor2 x11 (i1[11], cin, int_ip[11]);
	 
	//if cin == 1, int_ip = 2's complement	 
    CLA_12bit CLA (i0,int_ip,cin,sum,cout);    


////////////////////////////////////////////carrylookahead 필요//////////////////////////////////////////////////////////////////
endmodule


module booth_substep(
    input wire signed [11:0] acc,    //Current value of accumulator
    input wire signed [11:0] Q,  //Current value of Q (initially the multiplier)    
    input wire signed q0,       //Current value of q-1 th bit
    input wire signed [11:0] multiplicand,  //the multipliand
    output reg signed [11:0] next_acc,   //next accumulator value || value of 8 MSB's of 16 bit output [17:8]
    output reg signed [11:0] next_Q, //Next value of Q || value of 8 LSB's of 16 bit output [7:0]
    output reg q0_next);
    
	wire [11:0] addsub_temp;  //next value of q_-1 th bit
	
	eight_bit_adder_subractor myadd(Q[0], acc, multiplicand, addsub_temp);
	
		always @(*) begin	
		if(Q[0] == q0) begin
            q0_next = Q[0];
            next_Q = Q>>1;
            next_Q[11] = acc[0];
            //right shift
            next_acc = acc>>1;
            //with sign extension
			if (acc[11] == 1)
					next_acc[11] = 1;
		end

		else begin        //if Q[0] != q0 (that is,  q_-1 bit)
            q0_next = Q[0];
            next_Q = Q>>1;
            next_Q[11] = addsub_temp[0];
            //right shift
            next_acc = addsub_temp>>1;
            //with sign extension
			if (addsub_temp[11] == 1)
                next_acc[11] = 1; 
		end			
end	
endmodule 

module booth_multiplier(multiplier, multiplicand,product,CLK,RESETn);
	input signed[11:0] multiplier, multiplicand;
	input CLK, RESETn;
	
	output signed [23:0] product;
	
	wire signed [11:0] Q[0:10];  //an 8 bit (1byte) array, with a depth of 7 (0 to 6 rows of 1 byte each)
	wire signed [11:0] acc[0:11]; //an 8 bit (1byte) array, with a depth of 8 (0 to 7 rows of 1 byte each)
	wire signed [11:0] q0;
	wire qout;
	
	reg signed [11:0] multiplicand0, multiplicand1, multiplicand2;
	reg signed [11:0] Q1[0:10], Q2[0:10];
	reg signed [11:0] acc1[0:11], acc2[0:11];
	reg signed [11:0] q01, q02;
	
	wire signed [11:0] q011;
	wire signed [11:0] acc11[0:11];
	wire signed [11:0] Q11[0:10];
	
	wire signed [11:0] q022;
	wire signed [11:0] acc22[0:11];
	wire signed [11:0] Q22[0:10];
	
	always @ (posedge CLK, negedge RESETn)
	begin
		if (!RESETn)
		begin
		
			acc1[0] 			<= 0;
			acc1[1]			<= 0;
			acc1[2]			<= 0;
			acc1[3]			<= 0;
			acc1[4]			<= 0;
			acc1[5]			<= 0;
			acc1[6]			<= 0;
			acc1[7]			<= 0;
			acc1[8]			<= 0;
			acc1[9]			<= 0;
			acc1[10]			<= 0;		
			acc1[11]			<= 0;				
			
			acc2[0] 			<= 0;
			acc2[1]			<= 0;
			acc2[2]			<= 0;
			acc2[3]			<= 0;
			acc2[4]			<= 0;
			acc2[5]			<= 0;
			acc2[6]			<= 0;
			acc2[7]			<= 0;
			acc2[8]			<= 0;
			acc2[9]			<= 0;
			acc2[10]			<= 0;		
			acc2[11]			<= 0;	
			
			Q1[0] 			<= 0;
			Q1[1]				<= 0;
			Q1[2]				<= 0;
			Q1[3]				<= 0;
			Q1[4]				<= 0;
			Q1[5]				<= 0;
			Q1[6]				<= 0;
			Q1[7]				<= 0;
			Q1[8]				<= 0;
			Q1[9]				<= 0;
			Q1[10]			<= 0;
			
			Q2[0] 			<= 0;
			Q2[1]				<= 0;
			Q2[2]				<= 0;
			Q2[3]				<= 0;
			Q2[4]				<= 0;
			Q2[5]				<= 0;
			Q2[6]				<= 0;
			Q2[7]				<= 0;
			Q2[8]				<= 0;
			Q2[9]				<= 0;
			Q2[10]			<= 0;			
						
			q01 				<= 0;
			multiplicand1	<=	0;
			q02				<= 0;
			multiplicand2	<=	0;
		end	
		else
		begin
		multiplicand0	<=	multiplicand;
			//stage1->2
			acc1[0] 			<=acc[0];
			acc1[1]			<=acc[1];
			acc1[2]			<=acc[2];
			acc1[3]			<=acc[3];
			acc1[4]			<=acc[4];
			acc1[5]			<=acc[5];
			acc1[6]			<=acc[6];
			acc1[7]			<=acc[7];
			acc1[8]			<=acc[8];
			acc1[9]			<=acc[9];
			acc1[10]			<=acc[10];		
			acc1[11]			<=acc[11];	
		
			Q1[0] 			<= Q[0];
			Q1[1]				<= Q[1];
			Q1[2]				<= Q[2];
			Q1[3]				<= Q[3];
			Q1[4]				<= Q[4];
			Q1[5]				<= Q[5];
			Q1[6]				<= Q[6];
			Q1[7]				<= Q[7];
			Q1[8]				<= Q[8];
			Q1[9]				<= Q[9];
			Q1[10]			<= Q[10];
			
			q01				<= q0;					
			multiplicand1	<=	multiplicand0;
			//stage2->3
			acc2[0] 			<=acc11[0];
			acc2[1]			<=acc11[1];
			acc2[2]			<=acc11[2];
			acc2[3]			<=acc11[3];
			acc2[4]			<=acc11[4];
			acc2[5]			<=acc11[5];
			acc2[6]			<=acc11[6];
			acc2[7]			<=acc11[7];
			acc2[8]			<=acc11[8];
			acc2[9]			<=acc11[9];
			acc2[10]			<=acc11[10];		
			acc2[11]			<=acc11[10];	
			
			Q2[0] 			<= Q11[0];
			Q2[1]				<= Q11[1];
			Q2[2]				<= Q11[2];
			Q2[3]				<= Q11[3];
			Q2[4]				<= Q11[4];
			Q2[5]				<= Q11[5];
			Q2[6]				<= Q11[6];
			Q2[7]				<= Q11[7];
			Q2[8]				<= Q11[8];
			Q2[9]				<= Q11[9];
			Q2[10]			<= Q11[10];
			
			q02				<= q011;
			multiplicand2	<=	multiplicand1;	
		end	
	end
	assign acc[0] = 12'b00000000;   //initialising accumulator to 0
	
assign acc11[0] 			=acc1[0];
assign acc11[1]			=acc1[1];
assign acc11[2]			=acc1[2];
assign acc11[3]			=acc1[3];
assign acc11[4]			=acc1[4];
assign acc11[5]			=acc1[5];			
assign acc11[6]			=acc1[6];
assign acc11[7]			=acc1[7];
assign acc11[8]			=acc1[8];
assign acc11[9]			=acc1[9];
assign acc11[10]			=acc1[10];		
assign acc11[11]			=acc1[11];	

assign	Q11[0] 	= Q1[0];
assign	Q11[1]	= Q1[1];
assign	Q11[2]	= Q1[2];
assign	Q11[3]	= Q1[3];
assign	Q11[4]	= Q1[4];
assign	Q11[5]	= Q1[5];
assign	Q11[6]	= Q1[6];
assign	Q11[7]	= Q1[7];
assign	Q11[8]	= Q1[8];
assign	Q11[9]	= Q1[9];
assign	Q11[10]	= Q1[10];

assign q011 = q01;

assign acc22[0] 			=acc2[0];
assign acc22[1]			=acc2[1];
assign acc22[2]			=acc2[2];
assign acc22[3]			=acc2[3];
assign acc22[4]			=acc2[4];
assign acc22[5]			=acc2[5];			
assign acc22[6]			=acc2[6];
assign acc22[7]			=acc2[7];
assign acc22[8]			=acc2[8];
assign acc22[9]			=acc2[9];
assign acc22[10]			=acc2[10];		
assign acc22[11]			=acc2[11];	

assign	Q22[0] 	= Q2[0];
assign	Q22[1]	= Q2[1];
assign	Q22[2]	= Q2[2];
assign	Q22[3]	= Q2[3];
assign	Q22[4]	= Q2[4];
assign	Q22[5]	= Q2[5];
assign	Q22[6]	= Q2[6];
assign	Q22[7]	= Q2[7];
assign	Q22[8]	= Q2[8];
assign	Q22[9]	= Q2[9];
assign	Q22[10]	= Q2[10];

assign q022 = q02;
			
	//stage1
	booth_substep step1(acc[0], multiplier, 1'b0, multiplicand, acc[1],        Q[0],         q0[1]);
	booth_substep step2(acc[1], Q[0],      q0[1], multiplicand, acc[2],        Q[1],         q0[2]);
	booth_substep step3(acc[2], Q[1],      q0[2], multiplicand, acc[3],        Q[2],         q0[3]);
	booth_substep step4(acc[3], Q[2],      q0[3], multiplicand, acc[4],        Q[3],         q0[4]);
	//stage2
	booth_substep step5(acc11[4], Q11[3],      q011[4], multiplicand1, acc11[5],        Q11[4],         q011[5]);
	booth_substep step6(acc11[5], Q11[4],      q011[5], multiplicand1, acc11[6],        Q11[5],         q011[6]);
	booth_substep step7(acc11[6], Q11[5],      q011[6], multiplicand1, acc11[7],        Q11[6],         q011[7]);
	booth_substep step8(acc11[7], Q11[6],      q011[7], multiplicand1, acc11[8],        Q11[7],         q011[8]);
	//stage3
	booth_substep step9(acc22[8], Q22[7],      q022[8], multiplicand2, acc22[9],        Q22[8],         q022[9]);
	booth_substep step10(acc22[9], Q22[8],      q022[9], multiplicand2, acc22[10],        Q22[9],         q022[10]);
	booth_substep step11(acc22[10], Q22[9],      q022[10], multiplicand2, acc22[11],        Q22[10],         q022[11]);
	booth_substep step12(acc22[11], Q22[10],      q022[11], multiplicand2, product[23:12], product[11:0], qout);
	
	 
endmodule

//lib.v
//xor module
module xor2 (input wire i0, i1, output wire o);
  assign o = i0 ^ i1;
endmodule

module CLA_12bit(a,b,ci,sum,cout);

        input   [11:0]  a;
        input   [11:0]  b;
        input           ci;
        output  [11:0]  sum;
        output          cout;

        wire [2:0] GG;
        wire [2:0] PP;
        wire [2:1] C;

        CLALogic_3 CarryLogic_2 (GG[2:0], PP[2:0], ci, C[2:1], cout, GGG, PPP);
		  
        CLA4 u0 (a[3: 0] , b[3: 0],  ci  , sum[3: 0],  GG[0], PP[0]);
        CLA4 u1 (a[7: 4] , b[7: 4],  C[1], sum[7: 4],  GG[1], PP[1]);
        CLA4 u2 (a[11:8] , b[11:8], C[2], sum[11:8],  GG[2], PP[2]);


endmodule
module CLA4(A,B,Ci,S,GG,PP);
        input [3:0] A;
        input [3:0] B;
        input Ci;

        output [3:0] S;
        output PP;
        output GG;

        wire [3:0] G;
        wire [3:0] P;
        wire [3:1] C;

        CLALogic_4 CarryLogic (G, P, Ci, C, Co, GG, PP);

        GPFullAdder FA0 (A[0], B[0], Ci, G[0], P[0], S[0]);
        GPFullAdder FA1 (A[1], B[1], C[1], G[1], P[1], S[1]);
        GPFullAdder FA2 (A[2], B[2], C[2], G[2], P[2], S[2]);
        GPFullAdder FA3 (A[3], B[3], C[3], G[3], P[3], S[3]);

endmodule
module GPFullAdder(X,Y,Cin,G,P,Sum);
        input X;
        input Y;
        input Cin;
        output G;
        output P;
        output Sum;

        assign G=X&Y;
        assign P=X^Y;
        assign Sum=P^Cin;
endmodule

module CLALogic_4 (G, P, Ci, C, Co, GG, PP);
        input [3:0] G;
        input [3:0] P;
        input Ci;
        output [3:1] C;
        output Co;
        output PP;
        output GG;

        assign PP=P[3] & P[2] & P[1] & P[0];
        assign GG=G[3] |
                (P[3] & G[2]) |
                (P[3] & P[2] & G[1]) |
                (P[3] & P[2] & P[1] & G[0]);
        assign Co = GG | (PP & Ci);

        assign C[1] = G[0] | (P[0] & Ci);
        assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Ci);
        assign C[3] = G[2] | (P[2] & G[1]) | (P[2] & P[1] & G[0]) | (P[2] & P[1] & P[0] & Ci);
endmodule		  
module CLALogic_3 (G, P, Ci, C, Co, GG, PP);
        input [2:0] G;
        input [2:0] P;
        input Ci;
        output [2:1] C;
        output Co;
        output PP;
        output GG;

        assign PP=P[2] & P[1] & P[0];
        assign GG=G[2] |
                (P[2] & G[1]) |
                (P[2] & P[1] & G[0]);
        assign Co = GG | (PP & Ci);

        assign C[1] = G[0] | (P[0] & Ci);
        assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Ci);

endmodule
