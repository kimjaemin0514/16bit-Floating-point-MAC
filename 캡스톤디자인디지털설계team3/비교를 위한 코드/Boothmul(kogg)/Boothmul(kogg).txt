module TOP(multiplier, multiplicand,product,CLK,RESETn);

input [11:0] multiplier, multiplicand;
input CLK, RESETn;
output [23:0] product;
booth_multiplier TOP(.multiplier(multiplier), .multiplicand(multiplicand),.product(product),.CLK(CLK),.RESETn(RESETn));

endmodule

module xor2 (input wire i0, i1, output wire o);
  assign o = i0 ^ i1;
endmodule

module adder_subractor(cin,i0,i1,sum);

   input  cin;
   input  [11:0] i0,i1;
   output [11:0] sum;
	wire cout;
	wire [11:0] i1_1; 
	
	//if cin == 1, i1_1 = 1's complement
	//else i1_1 = i1
    xor2 x0 (i1[0], cin, i1_1[0]);
    xor2 x1 (i1[1], cin, i1_1[1]);
    xor2 x2 (i1[2], cin, i1_1[2]);
    xor2 x3 (i1[3], cin, i1_1[3]);
    xor2 x4 (i1[4], cin, i1_1[4]);
    xor2 x5 (i1[5], cin, i1_1[5]);
    xor2 x6 (i1[6], cin, i1_1[6]);
    xor2 x7 (i1[7], cin, i1_1[7]);
    xor2 x8 (i1[8], cin, i1_1[8]);
    xor2 x9 (i1[9], cin, i1_1[9]);
	 xor2 x10 (i1[10], cin, i1_1[10]);
	 xor2 x11 (i1[11], cin, i1_1[11]);
	 
	//if cin == 1, i1_1 = 2's complement	   
    ksa12 KSA(i0,i1_1,cin,sum,cout);

endmodule


module booth_substep(
    input wire signed [11:0] acc,    
    input [11:0] Q,     
    input q0,       
    input [11:0] multiplicand,  
    output reg signed [11:0] next_acc,   
    output reg [11:0] next_Q, 
    output reg q0_next);
    
	wire [11:0] result; 
	
	adder_subractor addsub(Q[0], acc, multiplicand, result);
	
		always @(*) begin	
		if(Q[0] == q0) begin
            //right shift
            q0_next = Q[0];
            next_Q = Q>>1;
            next_Q[11] = acc[0];
            next_acc = acc>>1;
            //with sign extension
			if (acc[11] == 1)
					next_acc[11] = 1;
		end

		else begin        
		      //right shift
            q0_next = Q[0];
            next_Q = Q>>1;
            next_Q[11] = result[0];
            //right shift
            next_acc = result>>1;
            //with sign extension
			if (result[11] == 1)
                next_acc[11] = 1; 
		end			
end	
endmodule 

module booth_multiplier(multiplier, multiplicand,product,CLK,RESETn);
	input [11:0] multiplier, multiplicand;
	input CLK, RESETn;
	
	output signed [23:0] product;
	
	wire signed [11:0] Q[0:10];  
	wire signed [11:0] acc[0:11]; 
	wire signed [11:0] q0;
	wire qout;
	
	reg signed [11:0] multiplicand0, multiplicand1, multiplicand2;
	reg signed [11:0] Q1[0:10], Q2[0:10];
	reg signed [11:0] acc1[0:11], acc2[0:11];
	reg signed [11:0] q01, q02;
	
	wire signed [11:0] q011;
	wire signed [11:0] acc11[0:11];
	wire signed [11:0] Q11[0:10];
	
	wire signed [11:0] q022;
	wire signed [11:0] acc22[0:11];
	wire signed [11:0] Q22[0:10];
	
	always @ (posedge CLK, negedge RESETn)
	begin
		if (!RESETn)
		begin
		
			acc1[0] 			<= 0;
			acc1[1]			<= 0;
			acc1[2]			<= 0;
			acc1[3]			<= 0;
			acc1[4]			<= 0;
			acc1[5]			<= 0;
			acc1[6]			<= 0;
			acc1[7]			<= 0;
			acc1[8]			<= 0;
			acc1[9]			<= 0;
			acc1[10]			<= 0;		
			acc1[11]			<= 0;				
			
			acc2[0] 			<= 0;
			acc2[1]			<= 0;
			acc2[2]			<= 0;
			acc2[3]			<= 0;
			acc2[4]			<= 0;
			acc2[5]			<= 0;
			acc2[6]			<= 0;
			acc2[7]			<= 0;
			acc2[8]			<= 0;
			acc2[9]			<= 0;
			acc2[10]			<= 0;		
			acc2[11]			<= 0;	
			
			Q1[0] 			<= 0;
			Q1[1]				<= 0;
			Q1[2]				<= 0;
			Q1[3]				<= 0;
			Q1[4]				<= 0;
			Q1[5]				<= 0;
			Q1[6]				<= 0;
			Q1[7]				<= 0;
			Q1[8]				<= 0;
			Q1[9]				<= 0;
			Q1[10]			<= 0;
			
			Q2[0] 			<= 0;
			Q2[1]				<= 0;
			Q2[2]				<= 0;
			Q2[3]				<= 0;
			Q2[4]				<= 0;
			Q2[5]				<= 0;
			Q2[6]				<= 0;
			Q2[7]				<= 0;
			Q2[8]				<= 0;
			Q2[9]				<= 0;
			Q2[10]			<= 0;			
			
			multiplicand0	<= 0;		
			q01 				<= 0;
			multiplicand1	<=	0;
			q02				<= 0;
			multiplicand2	<=	0;
		end	
		else
		begin
		multiplicand0	<=	multiplicand;
			//stage1->2
			acc1[0] 			<=acc[0];
			acc1[1]			<=acc[1];
			acc1[2]			<=acc[2];
			acc1[3]			<=acc[3];
			acc1[4]			<=acc[4];
			acc1[5]			<=acc[5];
			acc1[6]			<=acc[6];
			acc1[7]			<=acc[7];
			acc1[8]			<=acc[8];
			acc1[9]			<=acc[9];
			acc1[10]			<=acc[10];		
			acc1[11]			<=acc[11];	
		
			Q1[0] 			<= Q[0];
			Q1[1]				<= Q[1];
			Q1[2]				<= Q[2];
			Q1[3]				<= Q[3];
			Q1[4]				<= Q[4];
			Q1[5]				<= Q[5];
			Q1[6]				<= Q[6];
			Q1[7]				<= Q[7];
			Q1[8]				<= Q[8];
			Q1[9]				<= Q[9];
			Q1[10]			<= Q[10];
			
			q01				<= q0;					
			multiplicand1	<=	multiplicand0;
			//stage2->3
			acc2[0] 			<=acc11[0];
			acc2[1]			<=acc11[1];
			acc2[2]			<=acc11[2];
			acc2[3]			<=acc11[3];
			acc2[4]			<=acc11[4];
			acc2[5]			<=acc11[5];
			acc2[6]			<=acc11[6];
			acc2[7]			<=acc11[7];
			acc2[8]			<=acc11[8];
			acc2[9]			<=acc11[9];
			acc2[10]			<=acc11[10];		
			acc2[11]			<=acc11[10];	
			
			Q2[0] 			<= Q11[0];
			Q2[1]				<= Q11[1];
			Q2[2]				<= Q11[2];
			Q2[3]				<= Q11[3];
			Q2[4]				<= Q11[4];
			Q2[5]				<= Q11[5];
			Q2[6]				<= Q11[6];
			Q2[7]				<= Q11[7];
			Q2[8]				<= Q11[8];
			Q2[9]				<= Q11[9];
			Q2[10]			<= Q11[10];
			
			q02				<= q011;
			multiplicand2	<=	multiplicand1;	
		end	
	end
	assign acc[0] = 12'b00000000;   //initialising accumulator to 0
	
assign acc11[0] 			=acc1[0];
assign acc11[1]			=acc1[1];
assign acc11[2]			=acc1[2];
assign acc11[3]			=acc1[3];
assign acc11[4]			=acc1[4];
assign acc11[5]			=acc1[5];			
assign acc11[6]			=acc1[6];
assign acc11[7]			=acc1[7];
assign acc11[8]			=acc1[8];
assign acc11[9]			=acc1[9];
assign acc11[10]			=acc1[10];		
assign acc11[11]			=acc1[11];	

assign	Q11[0] 	= Q1[0];
assign	Q11[1]	= Q1[1];
assign	Q11[2]	= Q1[2];
assign	Q11[3]	= Q1[3];
assign	Q11[4]	= Q1[4];
assign	Q11[5]	= Q1[5];
assign	Q11[6]	= Q1[6];
assign	Q11[7]	= Q1[7];
assign	Q11[8]	= Q1[8];
assign	Q11[9]	= Q1[9];
assign	Q11[10]	= Q1[10];

assign q011 = q01;

assign acc22[0] 			=acc2[0];
assign acc22[1]			=acc2[1];
assign acc22[2]			=acc2[2];
assign acc22[3]			=acc2[3];
assign acc22[4]			=acc2[4];
assign acc22[5]			=acc2[5];			
assign acc22[6]			=acc2[6];
assign acc22[7]			=acc2[7];
assign acc22[8]			=acc2[8];
assign acc22[9]			=acc2[9];
assign acc22[10]			=acc2[10];		
assign acc22[11]			=acc2[11];	

assign	Q22[0] 	= Q2[0];
assign	Q22[1]	= Q2[1];
assign	Q22[2]	= Q2[2];
assign	Q22[3]	= Q2[3];
assign	Q22[4]	= Q2[4];
assign	Q22[5]	= Q2[5];
assign	Q22[6]	= Q2[6];
assign	Q22[7]	= Q2[7];
assign	Q22[8]	= Q2[8];
assign	Q22[9]	= Q2[9];
assign	Q22[10]	= Q2[10];

assign q022 = q02;
			
	//stage1
	booth_substep step1(acc[0], multiplier, 1'b0, multiplicand, acc[1],        Q[0],         q0[1]);
	booth_substep step2(acc[1], Q[0],      q0[1], multiplicand, acc[2],        Q[1],         q0[2]);
	booth_substep step3(acc[2], Q[1],      q0[2], multiplicand, acc[3],        Q[2],         q0[3]);
	booth_substep step4(acc[3], Q[2],      q0[3], multiplicand, acc[4],        Q[3],         q0[4]);
	//stage2
	booth_substep step5(acc11[4], Q11[3],      q011[4], multiplicand1, acc11[5],        Q11[4],         q011[5]);
	booth_substep step6(acc11[5], Q11[4],      q011[5], multiplicand1, acc11[6],        Q11[5],         q011[6]);
	booth_substep step7(acc11[6], Q11[5],      q011[6], multiplicand1, acc11[7],        Q11[6],         q011[7]);
	booth_substep step8(acc11[7], Q11[6],      q011[7], multiplicand1, acc11[8],        Q11[7],         q011[8]);
	//stage3
	booth_substep step9(acc22[8], Q22[7],      q022[8], multiplicand2, acc22[9],        Q22[8],         q022[9]);
	booth_substep step10(acc22[9], Q22[8],      q022[9], multiplicand2, acc22[10],        Q22[9],         q022[10]);
	booth_substep step11(acc22[10], Q22[9],      q022[10], multiplicand2, acc22[11],        Q22[10],         q022[11]);
	booth_substep step12(acc22[11], Q22[10],      q022[11], multiplicand2, product[23:12], product[11:0], qout);
	
	 
endmodule

module ksa12(
input [11:0] a,
input [11:0] b,
input cin,
output [11:0] sum,
output cout
);

wire [11:0] p,g,pp1,gg1,pp2,gg2,pp3,gg3,pp4,gg4;

//stage0 pg 생성
pg_cell stage0(a,b,p,g);

//stage1 
gray_cell s1_0(p[0],g[0],cin,gg1[0]);
black_cell s1_1(p[1],g[1],p[0],g[0],pp1[1],gg1[1]);
black_cell s1_2(p[2],g[2],p[1],g[1],pp1[2],gg1[2]);
black_cell s1_3(p[3],g[3],p[2],g[2],pp1[3],gg1[3]);
black_cell s1_4(p[4],g[4],p[3],g[3],pp1[4],gg1[4]);
black_cell s1_5(p[5],g[5],p[4],g[4],pp1[5],gg1[5]);
black_cell s1_6(p[6],g[6],p[5],g[5],pp1[6],gg1[6]);
black_cell s1_7(p[7],g[7],p[6],g[6],pp1[7],gg1[7]);
black_cell s1_8(p[8],g[8],p[7],g[7],pp1[8],gg1[8]);
black_cell s1_9(p[9],g[9],p[8],g[8],pp1[9],gg1[9]);
black_cell s1_10(p[10],g[10],p[9],g[9],pp1[10],gg1[10]);
black_cell s1_11(p[11],g[11],p[10],g[10],pp1[11],gg1[11]);

//stage2
assign gg2[0] = gg1[0];
gray_cell s2_0(pp1[1],gg1[1],cin,gg2[1]);
gray_cell s2_1(pp1[2],gg1[2],gg1[0],gg2[2]);
black_cell s2_2(pp1[3],gg1[3],pp1[1],gg1[1],pp2[3],gg2[3]);
black_cell s2_3(pp1[4],gg1[4],pp1[2],gg1[2],pp2[4],gg2[4]);
black_cell s2_4(pp1[5],gg1[5],pp1[3],gg1[3],pp2[5],gg2[5]);
black_cell s2_5(pp1[6],gg1[6],pp1[4],gg1[4],pp2[6],gg2[6]);
black_cell s2_6(pp1[7],gg1[7],pp1[5],gg1[5],pp2[7],gg2[7]);
black_cell s2_7(pp1[8],gg1[8],pp1[6],gg1[6],pp2[8],gg2[8]);
black_cell s2_8(pp1[9],gg1[9],pp1[7],gg1[7],pp2[9],gg2[9]);
black_cell s2_9(pp1[10],gg1[10],pp1[8],gg1[8],pp2[10],gg2[10]);
black_cell s2_10(pp1[11],gg1[11],pp1[9],gg1[9],pp2[11],gg2[11]);

//stage3
assign gg3[0] = gg2[0];
assign gg3[1] = gg2[1];
assign gg3[2] = gg2[2];
gray_cell s3_0(pp2[3],gg2[3],cin,gg3[3]);
gray_cell s3_1(pp2[4],gg2[4],gg2[0],gg3[4]);
gray_cell s3_2(pp2[5],gg2[5],gg2[1],gg3[5]);
gray_cell s3_3(pp2[6],gg2[6],gg2[2],gg3[6]);
black_cell s3_4(pp2[7],gg2[7],pp2[3],gg2[3],pp3[7],gg3[7]);
black_cell s3_5(pp2[8],gg2[8],pp2[4],gg2[4],pp3[8],gg3[8]);
black_cell s3_6(pp2[9],gg2[9],pp2[5],gg2[5],pp3[9],gg3[9]);
black_cell s3_7(pp2[10],gg2[10],pp2[6],gg2[6],pp3[10],gg3[10]);
black_cell s3_8(pp2[11],gg2[11],pp2[7],gg2[7],pp3[11],gg3[11]);

//stage4
assign gg4[0] = gg3[0];
assign gg4[1] = gg3[1];
assign gg4[2] = gg3[2];
assign gg4[3] = gg3[3];
assign gg4[4] = gg3[4];
assign gg4[5] = gg3[5];
assign gg4[6] = gg3[6];
gray_cell s4_0(pp3[7],gg3[7],cin,gg4[7]);
gray_cell s4_1(pp3[8],gg3[8],gg3[0],gg4[8]);
gray_cell s4_2(pp3[9],gg3[9],gg3[1],gg4[9]);
gray_cell s4_3(pp3[10],gg3[10],gg3[2],gg4[10]);
gray_cell s4_4(pp3[11],gg3[11],gg3[3],gg4[11]);

//result
assign cout = gg4[11];
assign sum[0] = p[0] ^ cin;
assign sum[11:1] = p[11:1] ^ gg4[10:0];

endmodule

module black_cell(
  input  p1,
  input  g1,
  input  p0,
  input  g0,
  output p,
  output g
);

assign g = g1 | (g0 & p1);
assign p = p1 & p0;

endmodule

module gray_cell(
  input  p1,
  input  g1,
  input  g0,
  output g
);

assign g = g1 | (g0 & p1);

endmodule

module pg_cell(
input [11:0] a,
input [11:0] b,
output [11:0] p,
output [11:0] g
);

assign p=a^b;
assign g=a&b;

endmodule
