module TOP(a,b,ci,sum,cout,CLK,RESETn);

        input   [11:0]  a;
        input   [11:0]  b;
        input           ci;
        output  [11:0]  sum;
        output          cout;
		  input CLK, RESETn;


CLA_12bit TOP(.a(a),.b(b),.ci(ci),.sum(sum),.cout(cout),.CLK(CLK),.RESETn(RESETn));
endmodule

module CLA_12bit(a,b,ci,sum,cout,CLK,RESETn);
					  input CLK, RESETn;
        input   [11:0]  a;
        input   [11:0]  b;
        input           ci;
        output  [11:0]  sum;
        output          cout;

        wire [2:0] GG;
        wire [2:0] PP;
        wire [2:1] C;
		  
		  reg   [11:0]  a0;
        reg   [11:0]  b0;
        reg           ci0; 
		  
always @ (posedge CLK)
begin
	a0 <= a;
	b0 <= b;
	ci0 <=ci;
end
        CLALogic_3 CarryLogic_2 (GG[2:0], PP[2:0], ci, C[2:1], cout, GGG, PPP);
		  
        CLA4 u0 (a0[3: 0] , b0[3: 0],  ci0  , sum[3: 0],  GG[0], PP[0]);
        CLA4 u1 (a0[7: 4] , b0[7: 4],  C[1], sum[7: 4],  GG[1], PP[1]);
        CLA4 u2 (a0[11:8] , b0[11:8], C[2], sum[11:8],  GG[2], PP[2]);



endmodule
module CLA4(A,B,Ci,S,GG,PP);
        input [3:0] A;
        input [3:0] B;
        input Ci;

        output [3:0] S;
        output PP;
        output GG;

        wire [3:0] G;
        wire [3:0] P;
        wire [3:1] C;

        CLALogic_4 CarryLogic (G, P, Ci, C, Co, GG, PP);

        GPFullAdder FA0 (A[0], B[0], Ci, G[0], P[0], S[0]);
        GPFullAdder FA1 (A[1], B[1], C[1], G[1], P[1], S[1]);
        GPFullAdder FA2 (A[2], B[2], C[2], G[2], P[2], S[2]);
        GPFullAdder FA3 (A[3], B[3], C[3], G[3], P[3], S[3]);

endmodule
module GPFullAdder(X,Y,Cin,G,P,Sum);
        input X;
        input Y;
        input Cin;
        output G;
        output P;
        output Sum;

        assign G=X&Y;
        assign P=X^Y;
        assign Sum=P^Cin;
endmodule

module CLALogic_4 (G, P, Ci, C, Co, GG, PP);
        input [3:0] G;
        input [3:0] P;
        input Ci;
        output [3:1] C;
        output Co;
        output PP;
        output GG;

        assign PP=P[3] & P[2] & P[1] & P[0];
        assign GG=G[3] |
                (P[3] & G[2]) |
                (P[3] & P[2] & G[1]) |
                (P[3] & P[2] & P[1] & G[0]);
        assign Co = GG | (PP & Ci);

        assign C[1] = G[0] | (P[0] & Ci);
        assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Ci);
        assign C[3] = G[2] | (P[2] & G[1]) | (P[2] & P[1] & G[0]) | (P[2] & P[1] & P[0] & Ci);
endmodule		  
module CLALogic_3 (G, P, Ci, C, Co, GG, PP);
        input [2:0] G;
        input [2:0] P;
        input Ci;
        output [2:1] C;
        output Co;
        output PP;
        output GG;

        assign PP=P[2] & P[1] & P[0];
        assign GG=G[2] |
                (P[2] & G[1]) |
                (P[2] & P[1] & G[0]);
        assign Co = GG | (PP & Ci);

        assign C[1] = G[0] | (P[0] & Ci);
        assign C[2] = G[1] | (P[1] & G[0]) | (P[1] & P[0] & Ci);

endmodule
