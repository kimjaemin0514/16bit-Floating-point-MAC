module TOP(A,B,OutOfBound_in,SUM,OutOfBound,CLK,RESETn);
input CLK,RESETn;
input [15:0] A,B;
input OutOfBound_in;
output [15:0] SUM;
output OutOfBound; 

floatingadd TOP (A,B,OutOfBound_in,SUM,OutOfBound,CLK,RESETn);

endmodule

module floatingadd(A,B,OutOfBound_in,SUM,OutOfBound,CLK,RESETn);
input CLK,RESETn;
input [15:0] A,B;
input OutOfBound_in;
output reg [15:0] SUM;
output reg OutOfBound;   //결과값이 0인것도 OutOfBound 취급함.

reg A_sign, B_sign, C_sign;
reg [4:0] A_exponent,B_exponent, diff;
reg [10:0] A_fraction, B_fraction;
reg [24:0] C_frac, C_frac2;  //13번 shift부터는 똑같음.
reg [9:0] C_fraction;
reg [5:0] C_exponent_1;
reg [4:0] C_exponent;

always @ (posedge CLK) begin
	if (OutOfBound_in)
		OutOfBound=1;
	else begin
	A_sign = A[15];
	A_exponent[4:0] = A[14:10];
	A_fraction = {1'b1,A[9:0]};

	B_sign = B[15];
	B_exponent = B[14:10];
	B_fraction = {1'b1,B[9:0]};
	
//A=B (exponent) & A=B (fraction)
if (A_exponent == B_exponent && A_fraction == B_fraction) begin
	if (A_sign==B_sign) begin
		C_sign = A_sign;
		C_exponent_1 = A_exponent+1;
		C_exponent = C_exponent_1 [4:0]; 
		C_fraction = A_fraction;
		end
		if (C_exponent_1[5] == 1'b1) 
			OutOfBound=1;
		else
			OutOfBound=0;	
end
else begin
	OutOfBound=1;
end
		
//A>B (fraction)
	if ( (A_exponent > B_exponent) || (A_exponent == B_exponent && A_fraction > B_fraction)) begin 
	C_sign = A_sign;
	diff = A_exponent - B_exponent;
	
		if (diff>=5'b01101) begin
			C_fraction = A_fraction[9:0];
			C_exponent = A_exponent;
			OutOfBound=0;
		end
		else begin 
			if (A_sign^B_sign) //A,B 부호 다른경우
				C_frac = (A_fraction << diff) - B_fraction;
			else 
				C_frac = (A_fraction << diff) + B_fraction;// A+B 계산 EXPONENT 공통	   //13번 shift부터는 똑같음.
		

	

//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1) begin
		if (C_frac[diff-1]==0)
			C_frac2 = C_frac;
		else	
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;
	end
	
	if (diff>=2) begin
		if (C_frac[diff-1]==0)
			C_frac2 = C_frac;
		else	
			if (C_frac[diff-2]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else 
				if (C_frac[diff]==1)
					C_frac2 = C_frac+(1'b1 << (diff));
				else
					C_frac2 = C_frac;	
	end
/////////////////////////////////////////////////////////////	
		if (C_frac2[diff+11] ==1 ) begin //overflow 발생경우
			C_fraction = C_frac2 >> (diff+1);
			C_exponent_1 = A_exponent + 1 ;
			if (C_exponent_1 >= 6'b1_00000)
				OutOfBound=1;
			else
				OutOfBound=0;
			C_exponent = C_exponent_1[4:0];
		end
	else begin
		C_fraction = C_frac2 >> diff;
		C_exponent_1 = A_exponent;
		if (C_exponent_1 >= 6'b1_00000)
			OutOfBound=1;
		else
			OutOfBound=0;
		C_exponent = C_exponent_1 [4:0];
	end
	end
end

//A<B인 경우
	
//B>A (fraction)
	if ( (B_exponent > A_exponent) || (B_exponent == A_exponent && B_fraction > A_fraction)) begin 
	C_sign = B_sign;
	diff = B_exponent - A_exponent;
	
		if (diff>=5'b01101) begin
			C_fraction = B_fraction[9:0];
			C_exponent = B_exponent;
			OutOfBound=0;
		end
		else begin 
			if (B_sign^A_sign) //B,A 부호 다른경우
				C_frac = (B_fraction << diff) - A_fraction;
			else 
				C_frac = (B_fraction << diff) + A_fraction;// B+A 계산 EXPONENT 공통	   //13번 shift부터는 똑같음.
		

	

//rounding (guard bit, round bit, stickybit) nearest even.////
	if (diff==0)
		C_frac2 = C_frac;
		
	if (diff==1) begin
		if (C_frac[diff-1]==0)
			C_frac2 = C_frac;
		else	
			if (C_frac[diff]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else
				C_frac2 = C_frac;
	end
	
	if (diff>=2) begin
		if (C_frac[diff-1]==0)
			C_frac2 = C_frac;
		else	
			if (C_frac[diff-2]==1)
				C_frac2 = C_frac+(1'b1 << (diff));
			else 
				if (C_frac[diff]==1)
					C_frac2 = C_frac+(1'b1 << (diff));
				else
					C_frac2 = C_frac;	
	end
/////////////////////////////////////////////////////////////	
		if (C_frac2[diff+11] ==1 ) begin //overflow 발생경우
			C_fraction = C_frac2 >> (diff+1);
			C_exponent_1 = B_exponent + 1 ;
			if (C_exponent_1 >= 6'b1_00000)
				OutOfBound=1;
			else
				OutOfBound=0;
			C_exponent = C_exponent_1[4:0];
		end
	else begin
		C_fraction = C_frac2 >> diff;
		C_exponent_1 = B_exponent;
		if (C_exponent_1 >= 6'b1_00000)
			OutOfBound=1;
		else
			OutOfBound=0;
		C_exponent = C_exponent_1 [4:0];
	end
	end
end
end
		SUM={C_sign,C_exponent,C_fraction};

end	
endmodule